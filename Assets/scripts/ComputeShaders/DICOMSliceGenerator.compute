#pragma kernel FrontBackTextureCalc
#pragma kernel RightLeftTextureCalc
#pragma kernel BottomTopTextureCalc

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> textureOutFrontBack;
RWTexture2D<float4> textureOutRightLeft;
RWTexture2D<float4> textureOutBottomTop;

RWStructuredBuffer<float> todicommatrix;
RWStructuredBuffer<float> toimgmatrix;
RWStructuredBuffer<float> voxelarr;

RWStructuredBuffer<float> frontforwardright;
RWStructuredBuffer<float> backbottomleft;

RWStructuredBuffer<float> dicomspace_dims;

float xcoord;
float ycoord;
float zcoord;

int rows;
int cols;
int slices;

float maxval;

[numthreads(16,16,1)]
void FrontBackTextureCalc (uint3 id : SV_DispatchThreadID) {

	int imgdim = 512;
	float imgdim_float = 512.0;

	// transform my id point 

	float xfrac = float(id.x)/imgdim_float; 
	float zfrac = float(id.y)/imgdim_float; 

	float dicomcoord[4];
	float outputmatrix[4];

	dicomcoord[0] = backbottomleft[0] + xfrac * dicomspace_dims[0];
	dicomcoord[1] = ycoord;
	dicomcoord[2] = backbottomleft[2] + zfrac * dicomspace_dims[2];
	dicomcoord[3] = 1;

	// now need to transform to img coords
	// foreach row of matrix
	for (int row = 0; row < 4; ++row) {
		float cur_sum = 0;
		for (int col = 0; col < 4; ++col) {
			cur_sum += toimgmatrix [(4*row) + col] * dicomcoord[col];
		}
		outputmatrix [row] = cur_sum;
	}

	// now need to set relevant pixel of texture
	int indexz = outputmatrix[2];
	int indexz_1 = indexz+1;
	int indexy = outputmatrix[1];
	int indexx = outputmatrix[0];

	float frac = outputmatrix[2] - float(int(outputmatrix[2]));
	float invfrac = 1.0 - frac; // weight to give lower

	// Get bottom val
	int inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz<0)||(indexz>=slices)){
		inbounds = 0;
	}
	float pixlval_bot = 0;
	if(inbounds == 1){
		 pixlval_bot = (voxelarr [(rows * cols) * indexz + (indexy * cols) + indexx])/maxval;
	}

	// Get top val
	inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz_1<0)||(indexz_1>=slices)){
		inbounds = 0;
	}
	float pixlval_top = 0;
	if(inbounds == 1){
		 pixlval_top = (voxelarr [(rows * cols) * indexz_1 + (indexy * cols) + indexx])/maxval;
	}

	float pixlval = invfrac * pixlval_bot + 
			frac*pixlval_top;

	textureOutFrontBack[id.xy] = float4(pixlval,pixlval,pixlval,1);

}

[numthreads(16,16,1)]
void RightLeftTextureCalc (uint3 id : SV_DispatchThreadID) {
	int imgdim = 512;
	float imgdim_float = 512.0;

	// transform my id point 

	float zfrac = float(id.y)/imgdim_float; 
	float yfrac = float(id.x)/imgdim_float; 

	float dicomcoord[4];
	float outputmatrix[4];

	dicomcoord[0] = xcoord;
	dicomcoord[1] = backbottomleft[1] + yfrac * dicomspace_dims[1];
	dicomcoord[2] = backbottomleft[2] + zfrac * dicomspace_dims[2];
	dicomcoord[3] = 1;

	// now need to transform to img coords
	// foreach row of matrix
	for (int row = 0; row < 4; ++row) {
		float cur_sum = 0;
		for (int col = 0; col < 4; ++col) {
			cur_sum += toimgmatrix [(4*row) + col] * dicomcoord[col];
		}
		outputmatrix [row] = cur_sum;
	}

	// now need to set relevant pixel of texture
	int indexz = outputmatrix[2];
	int indexz_1 = indexz+1;
	int indexy = outputmatrix[1];
	int indexx = outputmatrix[0];

	float frac = outputmatrix[2] - float(int(outputmatrix[2]));
	float invfrac = 1.0 - frac; // weight to give lower

	// Get bottom val
	int inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz<0)||(indexz>=slices)){
		inbounds = 0;
	}
	float pixlval_bot = 0;
	if(inbounds == 1){
		 pixlval_bot = (voxelarr [(rows * cols) * indexz + (indexy * cols) + indexx])/maxval;
	}

	// Get top val
	inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz_1<0)||(indexz_1>=slices)){
		inbounds = 0;
	}
	float pixlval_top = 0;
	if(inbounds == 1){
		 pixlval_top = (voxelarr [(rows * cols) * indexz_1 + (indexy * cols) + indexx])/maxval;
	}

	float pixlval = invfrac * pixlval_bot + 
			frac*pixlval_top;

	textureOutRightLeft[id.xy] = float4(pixlval,pixlval,pixlval,1);
}

[numthreads(16,16,1)]
void BottomTopTextureCalc (uint3 id : SV_DispatchThreadID) {
int imgdim = 512;
	float imgdim_float = 512.0;

	// transform my id point 

	float xfrac = float(id.x)/imgdim_float; 
	float yfrac = 1.0-float(id.y)/imgdim_float; 

	float dicomcoord[4];
	float outputmatrix[4];

	dicomcoord[0] = backbottomleft[0] + xfrac * dicomspace_dims[0];
	dicomcoord[1] = backbottomleft[1] + yfrac * dicomspace_dims[1];
	dicomcoord[2] = zcoord;
	dicomcoord[3] = 1;

	// now need to transform to img coords
	// foreach row of matrix
	for (int row = 0; row < 4; ++row) {
		float cur_sum = 0;
		for (int col = 0; col < 4; ++col) {
			cur_sum += toimgmatrix [(4*row) + col] * dicomcoord[col];
		}
		outputmatrix [row] = cur_sum;
	}

	// now need to set relevant pixel of texture
	int indexz = outputmatrix[2];
	int indexz_1 = indexz+1;
	int indexy = outputmatrix[1];
	int indexx = outputmatrix[0];

	float frac = outputmatrix[2] - float(int(outputmatrix[2]));
	float invfrac = 1.0 - frac; // weight to give lower

	// Get bottom val
	int inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz<0)||(indexz>=slices)){
		inbounds = 0;
	}
	float pixlval_bot = 0;
	if(inbounds == 1){
		 pixlval_bot = (voxelarr [(rows * cols) * indexz + (indexy * cols) + indexx])/maxval;
	}

	// Get top val
	inbounds = 1;
	if((indexx<0)||(indexx>=cols)){
		inbounds = 0;
	}
	if((indexy<0)||(indexy>=rows)){
		inbounds = 0;
	}
	if((indexz_1<0)||(indexz_1>=slices)){
		inbounds = 0;
	}
	float pixlval_top = 0;
	if(inbounds == 1){
		 pixlval_top = (voxelarr [(rows * cols) * indexz_1 + (indexy * cols) + indexx])/maxval;
	}

	float pixlval = invfrac * pixlval_bot + 
			frac*pixlval_top;

	textureOutBottomTop[id.xy] = float4(pixlval,pixlval,pixlval,1);
}
