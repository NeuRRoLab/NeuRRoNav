#pragma kernel FrontBackTextureCalc
#pragma kernel RightLeftTextureCalc
#pragma kernel BottomTopTextureCalc

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> textureOutFrontBack;
RWTexture2D<float4> textureOutRightLeft;
RWTexture2D<float4> textureOutBottomTop;

RWStructuredBuffer<float> todicommatrix;
RWStructuredBuffer<float> toimgmatrix;
RWStructuredBuffer<float> voxelarr;

RWStructuredBuffer<float> frontforwardright;
RWStructuredBuffer<float> backbottomleft;

RWStructuredBuffer<float> dicomspace_dims;

float xcoord;
float ycoord;
float zcoord;

int rows;
int cols;

float maxval;

[numthreads(16,16,1)]
void FrontBackTextureCalc (uint3 id : SV_DispatchThreadID) {

	int imgdim = 512;
	float imgdim_float = 512.0;

	// transform my id point 

	float xfrac = float(id.x)/imgdim_float; 
	float zfrac = float(id.y)/imgdim_float; 

	float dicomcoord[4];
	float outputmatrix[4];

	dicomcoord[0] = backbottomleft[0] + xfrac * dicomspace_dims[0];
	dicomcoord[1] = ycoord;
	dicomcoord[2] = backbottomleft[2] + zfrac * dicomspace_dims[2];
	dicomcoord[3] = 1;

	// now need to transform to img coords
	// foreach row of matrix
	for (int row = 0; row < 4; ++row) {
		float cur_sum = 0;
		for (int col = 0; col < 4; ++col) {
			cur_sum += toimgmatrix [(4*row) + col] * dicomcoord[col];
		}
		outputmatrix [row] = cur_sum;
	}

	// now need to set relevant pixel of texture
	int indexz = outputmatrix[2];
	int indexy = outputmatrix[1];
	int indexx = outputmatrix[0];

	float pixlval = (voxelarr [(rows * cols) * indexz + (indexy * cols) + indexx])/maxval;
	//float pixlval = voxelarr[rows*cols*50 + (128*cols)+int(ycoord*255)]/maxval;

	textureOutFrontBack[id.xy] = float4(pixlval,pixlval,pixlval,1);
	//textureOutFrontBack[id.xy] = float4(xfrac,ycoord,zfrac,1);
}

[numthreads(16,16,1)]
void RightLeftTextureCalc (uint3 id : SV_DispatchThreadID) {
	
}

[numthreads(16,16,1)]
void BottomTopTextureCalc (uint3 id : SV_DispatchThreadID) {
	
}
